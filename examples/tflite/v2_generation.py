"""
    TFMin v1.0 Minimal TensorFlow to C++ exporter
    ------------------------------------------

    Copyright (C) 2019 Pete Blacker, Surrey Space Centre & Airbus Defence and
    Space Ltd.
    Pete.Blacker@Surrey.ac.uk
    https://www.surrey.ac.uk/surrey-space-centre/research-groups/on-board-data-handling

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    in the LICENCE file of this software.  If not, see
    <http://www.gnu.org/licenses/>.

    ---------------------------------------------------------------------

    This example demonstrates a simple heap memory pre-allocation and
    generates a visualization of the buffer allocation pattern.
    Note. no c code is generated by this example.
"""
import tensorflow as tf
import scipy.io
import numpy as np
import argparse
import sys
import os

from tf_min import exporter as tfm_ex
from tf_min import graph as tfm_g
from tf_min import graph_from_tflite as g_gen
from tf_min import graph_2_svg as tfm_svg
from tf_min import graph_add_safe_overlaps as aso
import tf_min.graph_mem_2_svg as tfm_mem_svg
import tf_min.mem_opt.graph_heap_opt as tfm_heap_opt
import tf_min.mem_opt.graph_peak_reorder_opt as tfm_peak_reorder_opt
import tf_min.mem_opt.graph_seq_allocator as tfm_seq_opt
import tf_min.mem_opt.heap_smart_order as tfm_heap_smart_order
import tf_min.mem_opt.op_split as tfm_op_split
from tf_min.graph_c_gen import CodeGenerator


def load_and_sequence_graph(buffer, dmo=False):

    graph = g_gen.graph_from_tflite(buffer)
    sequencer = tfm_g.SequenceOps(graph)
    graph_seq = sequencer.translate()

    if dmo:
        aso.add_safe_overlaps_to_graph(graph_seq)

    return graph_seq


def load_and_export_model():

    flatbuffer_filename = "models/squeezenet.tflite"

    # read tflite flatbuffer
    try:
        fb_file = open(flatbuffer_filename, 'rb')
        flatbuffer = bytearray(fb_file.read())
    except IOError as err:
        print("Error failed to read flatbuffer file \"%s\" [%s]" %
              (flatbuffer_filename,
               str(err)))
        return

    # generate SVG of flow graph if requested
    print("Saving svg of models flow-graph.")
    graph = load_and_sequence_graph(flatbuffer)
    svg_writer = tfm_svg.SVGWriter(graph)
    svg_writer.write("original_input_graph.svg")
    print("Done.")

    # sequencer = tfm_g.SequenceOps(graph)
    # graph_seq = sequencer.translate(verbose=True)
    # graph_seq = graph

    print("\n==== Allocating memory using heap ordering ====")
    mem_opt = tfm_heap_opt.HeapAllocateGraph(
      load_and_sequence_graph(flatbuffer),
      {'order': 'forwards'}
    )
    graph_heap_alloc = mem_opt.translate(verbose=True)
    result_heap_order = graph_heap_alloc.get_peak_memory()
    mem_svg_writer = tfm_mem_svg.SVGMemoryWriter(graph_heap_alloc)
    mem_svg_writer.write("heap_order_memory.svg")
    print("Allocated into a %d byte tensor arena" % result_heap_order)
    print("-"*80)

    code_gen = CodeGenerator(graph=graph_heap_alloc,
                             prefix="namespace_",
                             base_name="squeeze_net")
    code_gen()


def main():

  load_and_export_model()


if __name__ == '__main__':
    main()
